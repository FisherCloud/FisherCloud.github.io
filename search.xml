<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CC2530+Contiki+LCD12864]]></title>
    <url>%2F2019%2F04%2F17%2FCC2530-Contiki-LCD12864%2F</url>
    <content type="text"><![CDATA[前言CC2530 + Contiki操作系统，使用LCD12864（SPI）。 驱动代码驱动代码放到 1$PROJ_DIR\contiki3.0\contiki-3.0\platform\cc2530dk\dev 不要忘了在工程里面添加 lcd_dis.h1234567891011121314151617181920212223242526272829303132333435363738394041424344#ifndef __LCD_DIS_h__#define __LCD_DIS_h__#define Dis_X_MAX 128-1#define Dis_Y_MAX 64-1//Define the MCU Register#define SPI_RES P0_0#define SPI_SCK P1_5#define SPI_SDA P1_6#define SPI_CS P1_2// write your header hereextern void TimeDelay( unsigned int Timers );extern void LCD_Init( void );extern void SPI_SSSet( unsigned char Status );extern void SPI_Send( unsigned char Data );extern void FontSet( unsigned char Font_NUM, unsigned char Color );extern void FontSet_cn( unsigned char Font_NUM, unsigned char Color );extern void PutChar( unsigned char x, unsigned char y, unsigned char a );extern void PutString( unsigned char x, unsigned char y, unsigned char* p );extern void PutChar_cn( unsigned char x, unsigned char y, unsigned char* GB );extern void PutString_cn( unsigned char x, unsigned char y, unsigned char* p );extern void SetPaintMode( unsigned char Mode, unsigned char Color );extern void PutPixel( unsigned char x, unsigned char y );extern void Line( unsigned char s_x, unsigned char s_y, unsigned char e_x, unsigned char e_y );extern void Circle( unsigned char x, unsigned char y, unsigned char r, unsigned char mode );extern void Rectangle( unsigned char left, unsigned char top, unsigned char right, unsigned char bottom, unsigned char mode );extern void ClrScreen( void );extern void PutBitmap( unsigned char x, unsigned char y, unsigned char width, unsigned char high, unsigned char* p );extern void FontMode( unsigned char Cover, unsigned char Color );extern void ShowChar( unsigned char x, unsigned char y, unsigned char a, unsigned char type ) ;extern void ShowShort( unsigned char x, unsigned char y, unsigned short a, unsigned char type ) ;extern void SetBackLight( unsigned char Deg );extern unsigned char X_Witch;extern unsigned char Y_Witch;extern unsigned char X_Witch_cn;extern unsigned char Y_Witch_cn;#endif lcd_dis.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549//========================================================================// 文件名: LCD_Dis.c// 日 期: 2009/02/10// 描 述: LCD显示模块驱动V1.0版// 基本功能接口函数集//// 参 考: 无// 版 本:// 2009/02/10 First version//========================================================================#include &quot;LCD_Dis.h&quot;#include &quot;port.h&quot;#include &quot;cc253x.h&quot;#include &quot;sys/clock.h&quot;#include &quot;port.h&quot;unsigned char X_Witch = 6;unsigned char Y_Witch = 10;unsigned char X_Witch_cn = 16;unsigned char Y_Witch_cn = 16;unsigned char Dis_Zero = 0;void LcdPortInit()&#123; PORT_DIR_OUTPUT( 0, 0 ); PORT_DIR_OUTPUT( 1, 2 ); PORT_DIR_OUTPUT( 1, 5 ); PORT_DIR_OUTPUT( 1, 6 ); /*MAKE_IO_PIN_OUTPUT(P0_DIR, 0); // MAKE_IO_PIN_OUTPUT(P1_DIR, 2); MAKE_IO_PIN_OUTPUT(P1_DIR, 5); // MAKE_IO_PIN_OUTPUT(P1_DIR, 6); */&#125;//========================================================================// 函数: void LCD_Init(void)// 描述: LCD初始化程序，主要在里面完成端口初始化以及LCD模块的复位// 参数: 无// 返回: 无// 备注:// 版本:// 2009/02/10 First version Mz Design//========================================================================void TimeDelay( unsigned int Timers )&#123; while( Timers-- ) &#123; clock_delay_usec( 1000 ); &#125;&#125;void LCD_Init( void )&#123; LcdPortInit(); //SS和SCK预先设置为高电平 SPI_SCK = 1; SPI_CS = 1; //复位LCD模块 SPI_RES = 0; TimeDelay( 50 ); //保持低电平大概2ms左右 SPI_RES = 1; TimeDelay( 80 ); //延时大概10ms左右&#125;//========================================================================// 函数: void SPI_SSSet(unsigned char Status)// 描述: 置SS线状态// 参数: Status =1则置高电平，=0则置低电平// 返回: 无// 版本:// 2009/02/10 First version Mz Design//========================================================================void SPI_SSSet( unsigned char Status )&#123; if( Status ) //判断是要置SS为低还是高电平？//SS置高电平 &#123; SPI_CS = 1; &#125; else //SS置低电平 &#123; SPI_CS = 0; &#125;&#125;//========================================================================// 函数: void SPI_Send(unsigned char Data)// 描述: 通过串行SPI口输送一个byte的数据置模组// 参数: Data 要传送的数据// 返回: 无// 版本:// 2007/07/17 First version// 2007/07/24 V1.2 for MCS51 Keil C//========================================================================void SPI_Send( unsigned char Data )&#123; unsigned char i = 0; for( i = 0; i &lt; 8; i++ ) &#123; //SCK置低 SPI_SCK = 0; if( Data &amp; 0x0080 ) &#123; SPI_SDA = 1; &#125; else &#123; SPI_SDA = 0; // &#125; //SCK上升沿触发串行数据采样 SPI_SCK = 1; Data = Data &lt;&lt; 1; //数据左移一位 &#125;&#125;//========================================================================// 函数: void FontSet(unsigned char Font_NUM,unsigned char Color)// 描述: ASCII字符字体设置// 参数: Font_NUM 字体选择,以驱动所带的字库为准// Color 文本颜色,仅作用于ASCII字库// 返回: 无// 备注:// 版本:// 2007/07/19 First version//========================================================================void FontSet( unsigned char Font_NUM, unsigned char Color )&#123; unsigned char ucTemp = 0; if( Font_NUM == 0 ) &#123; X_Witch = 6;//7; Y_Witch = 10; &#125; else &#123; X_Witch = 8; Y_Witch = 16; &#125; ucTemp = ( Font_NUM &lt;&lt; 4 ) | Color; //设置ASCII字符的字型 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 0x81 ); //传送指令0x81 SPI_Send( ucTemp ); //选择8X16的ASCII字体,字符色为黑色 SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void FontMode(unsigned char Cover,unsigned char Color)// 描述: 设置字符显示覆盖模式// 参数: Cover 字符覆盖模式设置，0或1// Color 覆盖模式为1时字符显示时的背景覆盖色// 返回: 无// 备注:// 版本:// 2008/11/27 First version//========================================================================void FontMode( unsigned char Cover, unsigned char Color )&#123; unsigned char ucTemp = 0; ucTemp = ( Cover &lt;&lt; 4 ) | Color; //设置ASCII字符的字型 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 0x89 ); //传送指令0x81 SPI_Send( ucTemp ); //选择8X16的ASCII字体,字符色为黑色 SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void FontSet_cn(unsigned char Font_NUM,unsigned char Color)// 描述: 汉字库字符字体设置// 参数: Font_NUM 字体选择,以驱动所带的字库为准// Color 文本颜色,仅作用于汉字库// 返回: 无// 备注:// 版本:// 2007/07/19 First version//========================================================================void FontSet_cn( unsigned char Font_NUM, unsigned char Color )&#123; unsigned char ucTemp = 0; if( Font_NUM == 0 ) &#123; X_Witch_cn = 12; Y_Witch_cn = 12; &#125; else &#123; X_Witch_cn = 16; Y_Witch_cn = 16; &#125; ucTemp = ( Font_NUM &lt;&lt; 4 ) | Color; //设置ASCII字符的字型 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 0x82 ); //传送指令0x81 SPI_Send( ucTemp ); //选择8X16的ASCII字体,字符色为黑色 SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void PutChar(unsigned char x,unsigned char y,unsigned char a)// 描述: 写入一个标准ASCII字符// 参数: x X轴坐标 y Y轴坐标// a 要显示的字符在字库中的偏移量// 返回: 无// 备注: ASCII字符可直接输入ASCII码即可// 版本:// 2007/07/19 First version//========================================================================void PutChar( unsigned char x, unsigned char y, unsigned char a )&#123; //显示ASCII字符 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 7 ); //传送指令0x07 SPI_Send( x ); //要显示字符的左上角的X轴位置 SPI_Send( y ); //要显示字符的左上角的Y轴位置 SPI_Send( a ); //要显示字符ASCII字符的ASCII码值 SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void PutString(int x,int y,char *p)// 描述: 在x、y为起始坐标处写入一串标准ASCII字符// 参数: x X轴坐标 y Y轴坐标// p 要显示的字符串// 返回: 无// 备注: 仅能用于自带的ASCII字符串显示// 版本:// 2007/07/19 First version//========================================================================void PutString( unsigned char x, unsigned char y, unsigned char* p )&#123; while( *p != 0 ) &#123; PutChar( x, y, *p ); x += X_Witch; if( ( x + X_Witch ) &gt; Dis_X_MAX ) &#123; x = Dis_Zero; if( ( Dis_Y_MAX - y ) &lt; Y_Witch ) &#123; break; &#125; else &#123; y += Y_Witch; &#125; &#125; p++; &#125;&#125;//========================================================================// 函数: void PutChar_cn(unsigned char x,unsigned char y,unsigned short * GB)// 描述: 写入一个二级汉字库汉字// 参数: x X轴坐标 y Y轴坐标// a GB码// 返回: 无// 备注:// 版本:// 2007/07/19 First version// 2007/07/24 V1.2 for MCS51 Keil C//========================================================================void PutChar_cn( unsigned char x, unsigned char y, unsigned char* GB )&#123; //显示ASCII字符 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 8 ); //传送指令0x08 SPI_Send( x ); //要显示字符的左上角的X轴位置 SPI_Send( y ); //要显示字符的左上角的Y轴位置 SPI_Send( *( GB++ ) ); //传送二级字库中汉字GB码的高八位值 SPI_Send( *GB ); //传送二级字库中汉字GB码的低八位值 SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void PutString_cn(unsigned char x,unsigned char y,unsigned short *p)// 描述: 在x、y为起始坐标处写入一串汉字字符// 参数: x X轴坐标 y Y轴坐标// p 要显示的字符串// 返回: 无// 备注: 同PutChar_cn中的解释// 版本:// 2007/07/19 First version// 2007/07/24 V1.2 for MCS51 Keil C//========================================================================void PutString_cn( unsigned char x, unsigned char y, unsigned char* p )&#123; while( *p != 0 ) &#123; if( *p &lt; 128 ) &#123; PutChar( x, y, *p ); x += X_Witch + 1; if( ( x/* + X_Witch*/ ) &gt; Dis_X_MAX ) &#123; x = Dis_Zero; if( ( Dis_Y_MAX - y ) &lt; Y_Witch ) &#123; break; &#125; else &#123; y += Y_Witch_cn; &#125; &#125; p += 1; &#125; else &#123; PutChar_cn( x, y, p ); x += X_Witch_cn + 1; if( ( x/* + X_Witch_cn*/ ) &gt; Dis_X_MAX ) &#123; x = Dis_Zero; if( ( Dis_Y_MAX - y ) &lt; Y_Witch_cn ) &#123; break; &#125; else &#123; y += Y_Witch_cn; &#125; &#125; p += 2; &#125; &#125;&#125;//========================================================================// 函数: void SetPaintMode(unsigned char Mode,unsigned char Color)// 描述: 绘图模式设置// 参数: Mode 绘图模式 Color 像素点的颜色,相当于前景色// 返回: 无// 备注: Mode无效// 版本:// 2007/07/19 First version//========================================================================void SetPaintMode( unsigned char Mode, unsigned char Color )&#123; unsigned char ucTemp = 0; ucTemp = ( Mode &lt;&lt; 4 ) | Color; //设置绘图模式 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 0x83 ); //传送指令0x83 SPI_Send( ucTemp ); //选择8X16的ASCII字体,字符色为黑色 SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void PutPixel(unsigned char x,unsigned char y)// 描述: 在x、y点上绘制一个前景色的点// 参数: x X轴坐标 y Y轴坐标// 返回: 无// 备注: 使用前景色// 版本:// 2007/07/19 First version//========================================================================void PutPixel( unsigned char x, unsigned char y )&#123; //绘点操作 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 1 ); //送指令0x01 SPI_Send( x ); //送第一个数据,即设置点的X轴位置 SPI_Send( y ); //点的Y轴位置 SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void Line(unsigned char s_x,unsigned char s_y,// unsigned char e_x,unsigned char e_y)// 描述: 在s_x、s_y为起始坐标，e_x、e_y为结束坐标绘制一条直线// 参数: x X轴坐标 y Y轴坐标// 返回: 无// 备注: 使用前景色// 版本:// 2007/07/19 First version//========================================================================void Line( unsigned char s_x, unsigned char s_y, unsigned char e_x, unsigned char e_y )&#123; //绘制直线 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 2 ); //送指令0x02 SPI_Send( s_x ); //起点X轴坐标 SPI_Send( s_y ); //起点Y轴坐标 SPI_Send( e_x ); //终点X轴坐标 SPI_Send( e_y ); //终点Y轴坐标 SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void Circle(unsigned char x,unsigned char y,// unsigned char r,unsigned char mode)// 描述: 以x,y为圆心R为半径画一个圆(mode = 0) or 圆面(mode = 1)// 参数:// 返回: 无// 备注: 画圆函数执行较慢，如果MCU有看门狗，请作好清狗的操作// 版本:// 2007/07/19 First version//========================================================================void Circle( unsigned char x, unsigned char y, unsigned char r, unsigned char mode )&#123; SPI_SSSet( 0 ); if( mode ) &#123; SPI_Send( 6 ); &#125; else &#123; SPI_Send( 5 ); &#125; SPI_Send( x ); SPI_Send( y ); SPI_Send( r ); SPI_SSSet( 1 );&#125;//========================================================================// 函数: void Rectangle(unsigned char left, unsigned char top, unsigned char right,// unsigned char bottom, unsigned char mode)// 描述: 以x,y为圆心R为半径画一个圆(mode = 0) or 圆面(mode = 1)// 参数: left - 矩形的左上角横坐标，范围0到126// top - 矩形的左上角纵坐标，范围0到62// right - 矩形的右下角横坐标，范围1到127// bottom - 矩形的右下角纵坐标，范围1到63// Mode - 绘制模式，可以是下列数值之一：// 0: 矩形框（空心矩形）// 1: 矩形面（实心矩形）// 返回: 无// 备注: 画圆函数执行较慢，如果MCU有看门狗，请作好清狗的操作// 版本:// 2007/07/19 First version//========================================================================void Rectangle( unsigned char left, unsigned char top, unsigned char right, unsigned char bottom, unsigned char mode )&#123; SPI_SSSet( 0 ); if( mode ) &#123; SPI_Send( 4 ); &#125; else &#123; SPI_Send( 3 ); &#125; SPI_Send( left ); SPI_Send( top ); SPI_Send( right ); SPI_Send( bottom ); SPI_SSSet( 1 );&#125;//========================================================================// 函数: void ClrScreen(void)// 描述: 清屏函数，执行全屏幕清除// 参数:// 返回: 无// 备注:// 版本:// 2007/07/19 First version//========================================================================void ClrScreen( void )&#123; //清屏操作 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 0x80 ); //送指令0x80 SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void PutBitmap(unsigned char x,unsigned char y,unsigned char width,// unsigned char high,unsigned char *p)// 描述: 在x、y为起始坐标显示一个单色位图// 参数: x X轴坐标 y Y轴坐标// width 位图的宽度// high 位图的高度// p 要显示的位图的字模首地址// 返回: 无// 备注: 无// 版本:// 2008/11/27 First version//========================================================================void PutBitmap( unsigned char x, unsigned char y, unsigned char width, unsigned char high, unsigned char* p )&#123; unsigned short Dat_Num; //unsigned short i; unsigned char ucTemp = 0; SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 0x0e ); SPI_Send( x ); SPI_Send( y ); SPI_Send( width ); SPI_Send( high ); width = width + 0x07; Dat_Num = ( width &gt;&gt; 3 ) * high; while( Dat_Num-- ) &#123; ucTemp++; SPI_Send( *p ); if( ucTemp &gt; 250 ) //如果改换别的MCU时,这里可能需要适当的调整 &#123; TimeDelay( 28 ); //以及此处,以保证前面传送到LCD模块中的数据已被处理完 ucTemp = 0; &#125; p++; &#125; SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void ShowChar(unsigned char x,unsigned char y,unsigned char Num,unsigned char type)// 描述: 在x、y的位置为显示区域的左上角，显示一个unsigned char型数// 参数: x X轴坐标 y Y轴坐标 Num 要显示的8位宽度的数据 type 显示特性(0,1,2)// 返回: 无// 备注:// 版本:// 2008/11/27 First version//========================================================================void ShowChar( unsigned char x, unsigned char y, unsigned char a, unsigned char type )&#123; //显示ASCII字符 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 11 ); //传送指令0x0B SPI_Send( x ); //要显示字符的左上角的X轴位置 SPI_Send( y ); //要显示字符的左上角的Y轴位置 SPI_Send( a ); //要显示的数据 SPI_Send( type ); SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void ShowShort(unsigned char x,unsigned char y,unsigned short Num,unsigned char type)// 描述: 在x、y的位置为显示区域的左上角，显示一个unsigned short型数（16位宽度）// 参数: x X轴坐标 y Y轴坐标 Num 要显示的16位宽度的数据 type 显示特性(0,1,2)// 返回: 无// 备注:// 版本:// 2008/11/27 First version//========================================================================void ShowShort( unsigned char x, unsigned char y, unsigned short a, unsigned char type )&#123; //显示ASCII字符 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 12 ); //传送指令0x0C SPI_Send( x ); //要显示字符的左上角的X轴位置 SPI_Send( y ); //要显示字符的左上角的Y轴位置 SPI_Send( ( unsigned char )( a &gt;&gt; 8 ) ); SPI_Send( ( unsigned char )a ); SPI_Send( type ); //要显示字符ASCII字符的ASCII码值 SPI_SSSet( 1 ); //完成操作置SS高电平&#125;//========================================================================// 函数: void SetBackLight(unsigned char Deg)// 描述: 设置背光亮度等级// 参数: Grade 0~127的等级// 返回: 无// 备注:// 版本:// 2008/11/27 First version//========================================================================void SetBackLight( unsigned char Deg )&#123; //显示ASCII字符 SPI_SSSet( 0 ); //SS置低电平 SPI_Send( 0x8a ); //传送指令0x07 SPI_Send( Deg ); //要显示字符的左上角的X轴位置 SPI_SSSet( 1 ); //完成操作置SS高电平&#125; 测试代码测试代码放到 1$PROJ_DIR\contiki3.0\contiki-3.0\examples\cc2530dk 不要忘了添加到工程里面 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &quot;contiki.h&quot;#include &quot;dev/lcd_dis.h&quot;PROCESS( lcd_test, &quot;lcd_test&quot; );AUTOSTART_PROCESSES( &amp;lcd_test );/** 主进程*/PROCESS_THREAD( lcd_test, ev, data )&#123; PROCESS_BEGIN(); LCD_Init(); SetBackLight( 100 ); //设置背光的亮度等级为0 ClrScreen(); //清屏 FontSet( 0, 1 ); //选择ASCII字符0(6X10),字符色为1(黑色) PutChar( 10, 0, &apos;A&apos; ); //在指定位置显示字符A FontSet( 1, 1 ); //选择ASCII字符1(8X16),字符色为1(黑色) PutChar( 20, 0, &apos;A&apos; ); //在指定位置显示字符A Rectangle( 64, 0, 127, 20, 1 ); //在指定位置绘制一个黑色的矩形作背景 FontSet( 1, 0 ); //选择ASCII字符1(8X16),字符色为0(白色) FontMode( 0, 1 ); //设置字符覆盖模式为禁止，字符背景覆盖色为1 PutChar( 70, 1, &apos;B&apos; ); //显示ASCII字符 FontSet( 1, 1 ); //选择ASCII字符1(8X16),字符色为1(黑色) FontMode( 1, 0 ); //设置字符覆盖模式为使能，字符背景覆盖色为0 PutChar( 80, 1, &apos;a&apos; ); //显示ASCII字符 PutString( 0, 17, &quot;Emdoor&quot; ); //在指定位置开始显示ASCII字符串 FontSet( 0, 1 ); PutString( 66, 23, &quot;--Emdoor04&quot; ); FontSet_cn( 1, 1 ); PutChar_cn( 10, 33, &quot;显&quot; ); PutString_cn( 40, 33, &quot;液晶测试&quot; ); FontSet_cn( 0, 1 ); PutChar_cn( 10, 50, &quot;显&quot; ); PutString_cn( 40, 50, &quot;汉字库液晶&quot; ); while( 1 ); PROCESS_END();&#125;]]></content>
      <categories>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>Contiki</tag>
        <tag>CC2530</tag>
        <tag>LCD12864</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CC2530+Contiki+DS18B20+LCD12864]]></title>
    <url>%2F2019%2F04%2F17%2FCC2530-Contiki-DS18B20-LCD12864%2F</url>
    <content type="text"><![CDATA[前言CC2530 + Contiki操作系统，使用DS18B20温度传感器进行温度的采集和显示（串口打印和LCD显示）。 驱动代码LCD程序驱动参考CC2530+Contiki+LCD12864【传送门】 ds18b20.h驱动代码放到 1$PROJ_DIR\contiki3.0\contiki-3.0\platform\cc2530dk\dev 不要忘了在工程里面添加 12345678910111213141516171819202122232425262728293031323334353637383940#ifndef DS18B20_H_#define DS18B20_H_#include &quot;cc253x.h&quot;#include &quot;sys/clock.h&quot;/************************************************** 以下定义为DS18B20支持的所有命令***************************************************/#define SEARCH_ROM 0xF0 //搜索ROM#define READ_ROM 0x33 //读ROM#define MATCH_ROM 0x55 //匹配ROM(挂多个DS18B20时使用)#define SKIP_ROM 0xCC //跳过匹配ROM(单个DS18B20时跳过)#define ALARM_SEARCH 0xEC //警报搜索#define CONVERT_T 0x44 //开始转换温度#define WR_SCRATCHPAD 0x4E //写便笺#define RD_SCRATCHPAD 0xBE //读便笺#define CPY_CCTATCHPAD 0x48 //复制便笺#define RECALL_EE 0xB8 //未启用#define RD_PWR_SUPPLY 0xB4 //读电源供应#define DQ P1_7 //DS18B20数据IO口#define DQ_DIR_OUT 0x80 //DS18B20 IO方向#define CL_DQ() DQ = 0 //清除数据#define SET_DQ() DQ = 1 //设置数据#define SET_OUT() P1DIR |= DQ_DIR_OUT //设置IO方向,out设置IO方向为输出#define SET_IN() P1DIR &amp;= ~DQ_DIR_OUT //设置IO方向,in设备IO方向为输入extern void DS18B20_Write(unsigned char x); //DS18B20写命令extern unsigned char DS18B20_Read(void); //DS18B20读数据extern void DS18B20_Init(void); //DS18B20初始化/复位extern void DS18B20_SendConvert(void); //发送转换温度命令extern void DS18B20_GetTem(unsigned char *integer, unsigned char *decimal); //DS18B20获取温度#endif ds18b20.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &quot;ds18b20.h&quot;/* * 写命令函数 * 输入参数： 命令（DS18B20.H中定义） * 输出参数： 无 * 返回参数： 无 * */void DS18B20_Write( unsigned char cmd )&#123; unsigned char i; SET_OUT(); //设置IO为输出，2530-&gt;DS18B20 /*每次一位，循环8次*/ for( i = 0; i &lt; 8; i++ ) &#123; CL_DQ(); //IO为低 if( cmd &amp; ( 1 &lt;&lt; i ) ) //写数据从低位开始 &#123; SET_DQ(); //IO输入高电平 &#125; else &#123; CL_DQ(); //IO输出低电平 &#125; clock_delay_usec( 40 ); //保持15~60us SET_DQ(); //IO口拉高 &#125; SET_DQ(); //IO口拉高&#125;/* * 读数据函数 * 输入参数： 无 * 输出参数： 无 * 返回参数： 读取的数据 * */unsigned char DS18B20_Read( void )&#123; unsigned char rdData; //读出的数据 unsigned char i, dat; //临时变量 rdData = 0; //读出的数据初始化为0 /* 每次读一位，读8次 */ for( i = 0; i &lt; 8; i++ ) &#123; CL_DQ(); //IO拉低 SET_DQ(); //IO拉高 SET_IN(); //设置IO方向为输入 DS18B20-&gt;CC2530 dat = DQ; //读数据,从低位开始 if( dat ) &#123; rdData |= ( 1 &lt;&lt; i ); //如果读出的数据位为正 &#125; else &#123; rdData &amp;= ~( 1 &lt;&lt; i ); //如果读出的数据位为负 &#125; clock_delay_usec( 70 ); //保持60~120us SET_OUT(); //设置IO方向为输出 CC2530-&gt;DS18B20 &#125; return ( rdData ); //返回读出的数据&#125;/* * DS18B20初始化/复位函数 * 输入参数： 无 * 输出参数： 无 * 返回参数： 无 * */void DS18B20_Init( void )&#123; unsigned char x = 60; do &#123; SET_OUT(); SET_DQ(); //IO口拉高 CL_DQ(); //IO口拉低 clock_delay_usec( 500 ); //IO拉低后保持一段时间 480-960us SET_DQ(); //释放 SET_IN(); //IO方向为输入 DS18B20-&gt;CC2530 clock_delay_usec( 20 ); //释放总线后等待15-60us &#125; while( x-- &amp;&amp; DQ ); /* 等待DQ变低 */ clock_delay_usec( 100 ); //检测到DQ 变低后，延时60-240us SET_OUT(); //设置IO方向为输出 CC2530-&gt;DS18B20 SET_DQ(); //IO拉高&#125;/* * DS18B20 转换温度函数 * 输入参数： 无 * 输出参数： 无 * 返回参数： 无 * */void DS18B20_SendConvert( void )&#123; DS18B20_Init(); //复位18B20 DS18B20_Write( SKIP_ROM ); //发出跳过ROM匹配操作 DS18B20_Write( CONVERT_T ); //启动温度转换&#125;/* * DS18B20获取温度函数 * 输入参数： 无 * 输出参数： 无 * 返回参数： 无 * */void DS18B20_GetTem( unsigned char* integer, unsigned char* decimal )&#123; unsigned char tem_h, tem_l; //温度高位字节及低位字节 unsigned char a, b; //临时变量 unsigned char flag; //温度正负标记，正为0，负为1 unsigned char FRACTION_INDEX[16] = &#123;0, 1, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9 &#125;;//小数值查询表 DS18B20_Init(); //DS18B20复位 DS18B20_Write( SKIP_ROM ); //跳过ROM匹配 DS18B20_Write( RD_SCRATCHPAD ); //写便笺 tem_l = DS18B20_Read(); //读温度低位 tem_h = DS18B20_Read(); //读温度高位 /* 判断温度正负 */ if( tem_h &amp; 0x80 ) &#123; flag = 1; //温度为负 a = ( tem_l &gt;&gt; 4 ); //取温度低4位原码 b = ( tem_h &lt;&lt; 4 ) &amp; 0xf0; //取温度高4位原码 tem_h = ~( a | b ) + 1; //取整数部分数值，不符号位 tem_l = ~( a &amp; 0x0f ) + 1; //取小数部分原值，不含符号位 &#125; else &#123; flag = 0; //为正 a = tem_h &lt;&lt; 4; a += ( tem_l &amp; 0xf0 ) &gt;&gt; 4; //得到整数部分值 b = tem_l &amp; 0x0f; //得出小数部分值 tem_h = a; //整数部分 tem_l = b &amp; 0xff; //小数部分 &#125; *decimal = FRACTION_INDEX[tem_l]; //查表得小数值 *integer = tem_h | ( flag &lt;&lt; 7 ); //整数部分，包括符号位&#125; 主进程代码新建一个C文件，添加到以下目录 1$PROJ_DIR\contiki3.0\contiki-3.0\examples\cc2530dk 不要忘了添加到工程里面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &quot;contiki.h&quot;#include &quot;dev/ds18b20.h&quot;#include &quot;sys/clock.h&quot;#include &quot;lcd_dis.h&quot;PROCESS( get_ds18b20_val, &quot;get ds18b20 value&quot; );AUTOSTART_PROCESSES( &amp;get_ds18b20_val );unsigned char integer, decimal;char temp[20];/** * 自定义延时函数 */void delay_ms( uint16_t dt )&#123; while( dt-- )clock_delay_usec( 1000 );&#125;;/** 主进程*/PROCESS_THREAD( get_ds18b20_val, ev, data )&#123; PROCESS_BEGIN(); // DS18B20 初始化 DS18B20_SendConvert(); // LCD 初始化 LCD_Init(); SetBackLight( 0 ); //设置背光的亮度等级为0 ClrScreen(); //清屏 FontSet_cn( 1, 1 ); FontSet( 1, 1 ); FontMode( 1, 0 ); while( 1 ) &#123; DS18B20_SendConvert(); DS18B20_GetTem( &amp;integer, &amp;decimal ); if( integer &lt; 100 ) &#123; ClrScreen(); //清屏 sprintf( temp, &quot;当前温度:%d.%d℃&quot;, integer, decimal ); printf( &quot;%s\r\n&quot;, temp ); PutString_cn( 0, 0, temp ); &#125; if( integer &gt; 31 ) &#123; printf(&quot;当前温度过高！\r\n&quot;); PutString_cn( 0, 16, &quot;当前温度过高!&quot; ); &#125; delay_ms( 1000 ); &#125; PROCESS_END();&#125; 效果]]></content>
      <categories>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>Contiki</tag>
        <tag>CC2530</tag>
        <tag>DS18B20</tag>
        <tag>LCD12864</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于MQTT的智能家庭网关研究与设计]]></title>
    <url>%2F2019%2F04%2F16%2F2019InnovativeTraining%2F</url>
    <content type="text"><![CDATA[基于MQTT的智能家庭网关研究与设计 四川师范大学大学生创新创业训练计划项目申 报 书 项目名称 基于MQTT的智能家庭网关研究与设计 项目负责人 余鑫 学号 2016110252 性别 男 班级 计算机科学学院2016级2班 Email 903426943@qq.com 联系电话 15984823634 一、项目简介当前物联网中数据的增长大大超过了网络带宽的增速, 这对物联网通信提出了巨大挑战，且家庭网关在家庭物联网的中枢承载着必不可少的作用;而通信协议又是通信中的关键问题。论述了物联网对通信协议的要求, 并认为MQTT协议符合了物联网通信的要求。在此基础上决定自主开发基于MQTT协议的一种智能家庭网关，并且能够实现异构的智能家居设备进行无缝集成。 二、申请理由立项依据随着科学技术的不断发展, 信息技术的不断提升, 互联网社会成为主流, 国家对物联网、互联网的大力支持, 使得物联网在不断地走进人们的生活, 成为我们生活中不可缺少的一部分。同时, 智能家居在此环境下得到了一定的发展, 以及广泛的使用, 随着人们的生活品质在不断的提升, 智能家居在一定程度上满足了人们对高水平生活的追求。所以, 物联网时代下的智能家居的发展成为了关键性问题, 现如今人们志在发展出安全性、艺术性的智能家居, 希望可以为社会的进步与发展做出更多的努力。 当前物联网风起云涌, 物联网连接的设备数量正在呈爆炸式速度递增, 确保从设备与云端之间可靠地进行双向的大规模数据传输以及确保数据传输的安全都是至关重要的。 在智能家居的网络信息传输中，是通过远程控制以及近程控制相互结合来完成最终的信息数据的传递与交流的。在信息传输系统的设计中，智能家居网关和外部服务器起着重要的作用，智能家居通过网关以及外部服务器的相互合作，共同来完成最终的信息的传递以及交流。在智能家居系统信息的传递中，网关对已经订阅的消息通过外部服务器的数据传输进行处理接收工作,同时，外部服务器通过自身的工作对网关发出的消息进行接收处理，达到数据的良好沟通。 自身及团队具备的知识团队共5名成员，4人（余鑫、何润、袁政伟、仲治宇）来自计算机科学与技术（物联网方向）2016级2班成员，1人（贾苹）来自2018级计算机专业。 自身具备的知识 具备两年半的嵌入式开发经验 自主完成了多个嵌入式、物联网相关实例 能够熟练使用多种嵌入式设备进行开发（51单片机、STM32、树莓派、ARM9、CC2530等） 能够熟练使用Altium Designer软件进行PCB电路板绘制 熟悉Linux操作系统及相关命令 熟悉Qt开发 能够进行简单的Android程序开发 团队具备的知识 何润 熟悉嵌入式相关开发 熟悉网络安全相关算法 熟悉Qt、C#开发 袁政伟 具有Web服务器开发经验 熟悉服务器相关框架 熟悉Web、Android程序开发 仲治宇 能够熟练进行嵌入式相关开发 熟悉IOS、Android、Qt开发 熟悉Linux开发环境 贾苹 熟悉单片机开发 能够熟练编写传感器、家居控制等程序 前期准备前期已经编写相应传感器程序及控制程序，且能够正确采集数据和控制，Zigbee模块组网正在测试中；能够对ARM9进行Linux移植，能够在ARM9部署简单的Qt应用程序；能够在云端部署Web服务器，并能完成简单的开发；能够在手机端连接本地服务器进行做简单的无线控制。 前期准备部分展示 附部分参考文献[1] 郭荣佐,郭进,黎明.智能家居中异构设备无缝集成的多协议网关设计[J].小型微型计算机系统,2015,36(10):2395-2402.[2] 满莎,杨恢先,彭友,王绪四.基于ARM9的嵌入式无线智能家居网关设计[J].计算机应用,2010,30(09):2541-2544.[3] 卢于辉,秦会斌.基于MQTT的智能家居系统的设计与实现[J].智能物联技术,2019,51(02):41-47. 三、项目方案与进度安排1、方案设计 图1 系统架构 MQTTMQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的”轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 MQTT是一个基于客户端-服务器的消息发布/订阅传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。 图2 MQTT 硬件设计硬件设计包括三星的ARM9芯片S5P6818（家庭网关）、CC2530模块（协调器）、传感器终端（CC2530+Sensor）、家居控制终端（CC2530+Things），如下图所示。S5P6818上部署MQTT服务器作为家庭网关，负责对整个智能家居设备的管理以及环境监控。由于智能家居中许多家电设备都通过Zigbee（CC2530）无线传输网络来工作，因此在S5P6818上添加CC2530模块对整个Zigbee无线传输网络的数据融合处理，协调器负责家庭内部的Zigbee网络的管理与控制。S5P6818中的WiFi模块可以通过无线访问节点（Access Point，AP）路由器与以太网进行连接，实现家庭内部网络与Internet之间的通信。 图3 硬件设计 软件设计软件设计包括MQTT服务器、Qt编写的网关应用程序、OpenWrt、云端Web服务器、云端数据库、智能终端APP，如下图所示。S5P6818家庭网关采用开源Linux操作系统，部署本地MQTT服务器并使用Qt编写网关应用程序，可以在本地管理和监控家居环境，也可把数据传送至云端服务器和数据库；云端采用CentOS操作系统作为服务器环境，部署web服务器和MySql数据库境；编写Android APP，能够连接云端服务器实现远程管理和监控家居环境。 图4 软件设计 2、进度安排第一阶段（5月）完成项目的详细文档、任务分工； 第二阶段（6月-7月）绘制并印刷Zigbee模块的PCB，完成CC2530组网，能够使用传感器数据采集和家居控制； 第三阶段（8月-9月）进行网关开发，部署MQTT服务器，进行Qt应用程序开发，同步进行Web服务器和Android APP开发； 第四阶段（10月-11月）完成网关与Zigbee模块的通信，能够在S5P6818网关上处理CC2530传感器节点采集到的数据，能够实现本地管理和监控家居环境，并根据进度对网关的算法调度等进行优化； 第五阶段（12月-1月）完成S5P6818网关和云端服务器的相关任务，完成Android APP功能开发，能够实现远程管理和监控家居环境； 第六阶段（2月-4月）完成项目所有测试，编写项目报告。 四、项目特色和创新MQTT的设计思想是开源、可靠、轻巧、简单，符合家居环境的要求，且拥有QOS0、QOS1、QOS2三种不同的服务质量，可以保证消息传输的可靠性。并且MQTT协议无需订阅者与发布者进行直连，这在一定程度上降低了设备随时进行消息传输的功耗，增强了移动设备进行远程管理和监控的可行性。能够将异构的智能家居设备进行无缝集成。 五、预测成果基本完成基于MQTT的智能家庭网关研究与设计，能够稳定的管理和监控家居环境。 六、项目经费支出预算 序号 支出类型 金额 测试依据 1 耗材 4000.00 电子元器件及相应测试模块 2 耗材 2000.00 印刷电路板（PCB） 3 耗材 1000.00 电路测试工具及焊接工具 4 印刷 500.00 资料印刷 5 图书资料 500.00 无线传感器网络、操作系统、数据处理、电路分析等相关图书资料]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>智能网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【单片机】基于单片机的智能语音控制系统]]></title>
    <url>%2F2019%2F04%2F05%2FLD3320A%2F</url>
    <content type="text"><![CDATA[前言 成员四川师范大学-计算机科学学院 计算机科学与技术（物联网） 2016110205 陈加兰 2016110228 刘雨霜 2016110252 余鑫]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>STM32F103C8T6</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】contiki for CC2530的IAR移植]]></title>
    <url>%2F2019%2F04%2F03%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91contiki-for-CC2530%E7%9A%84IAR%E7%A7%BB%E6%A4%8D%2F</url>
    <content type="text"><![CDATA[【引言】移植的必要性 通过移植Contiki到IAR环境，可以很清晰的查看contiki操作系统的细节，同时IAR开发环境支持CC2530在线仿真，这对于WSN网络是十分有用的，有效地。这也是为什么喜欢2530的原因。 概述通过移植Contiki到IAR环境，可以很清晰的查看contiki操作系统的细节，同时IAR开发环境支持CC2530在线仿真，这对于WSN网络是十分有用的，有效地。这也是为什么喜欢2530的原因。 你将学到 如何移植contiki到IAR环境。 关于移植的细节 【IAR文件路径】123456789101112131415161718192021$TOOLKIT_DIR$\INC\DLIB\C\$PROJ_DIR$\contiki-2.7\$PROJ_DIR$\contiki-2.7\core\$PROJ_DIR$\contiki-2.7\core\cfs\$PROJ_DIR$\contiki-2.7\core\ctk\$PROJ_DIR$\contiki-2.7\core\dev\$PROJ_DIR$\contiki-2.7\core\lib\$PROJ_DIR$\contiki-2.7\core\loader\$PROJ_DIR$\contiki-2.7\core\net\$PROJ_DIR$\contiki-2.7\core\net\mac\$PROJ_DIR$\contiki-2.7\core\net\rime\$PROJ_DIR$\contiki-2.7\core\net\routing\$PROJ_DIR$\contiki-2.7\core\sys\$PROJ_DIR$\contiki-2.7\cpu\$PROJ_DIR$\contiki-2.7\cpu\cc253x\$PROJ_DIR$\contiki-2.7\cpu\cc253x\dev\$PROJ_DIR$\contiki-2.7\platform\$PROJ_DIR$\contiki-2.7\platform\cc2530dk\$PROJ_DIR$\contiki-2.7\platform\cc2530dk\dev\$PROJ_DIR$\contiki-2.7\examples\$PROJ_DIR$\contiki-2.7\examples\hello-world\ 【相关宏定义】12UIP_CONF_IPV6=1VP_CONFIG_H=&quot;contiki-conf.h 【GDCC到IAR的编译修改】(1) asm未定义GCC下关键字asm，等同于IAR的asm。不过，从文档《IAR C/C++ Compiler Reference Guide.pdf》来看，推荐使用关键字asm(英文原文：the asm keyword is not available when the option –strict is used. The asm keyword is always available)。在相应文件增加如下代码，即可解决： 123#ifdef __IAR_SYSTEMS_ICC__#define __asm__ __asm#endif (2)变量1__xdata __at(0x0000) static unsigned long timer_value = 0; 变成 1static volatile unsigned long timer_value = 0; 更恰当的修改 1//static CC_AT_DATA struct timer debouncetimer; 变成 12345#ifdef SDCCstatic__data structtimer debouncetimer;#elsestaticstruct timer debouncetimer;#endif 关于中断 1void 2 port_0_isr(void) __interrupt(P0INT_VECTOR) 修改成 1234567#ifdef SDCCvoidport_0_isr(void) __interrupt(P0INT_VECTOR)#else#pragma vector=P0INT_VECTOR__near_func __interrupt void port_0_isr(void)#endif 1， 根据iocc2530.h修改了cc253x.h 为了找到cc2530的IEEE Addres，在cc253x.h（改编自iocc2530.h）中添加了 1#define X_IEEE_ADDR PXREG(0x780C ) /* Start of unique IEEE Address */ 2，中断服务函数 linux 下是SDCC 要改成IAR格式 1void rtimer_isr(void) __interrupt(T1_VECTOR); 改成 123456#ifdef SDCC void port_0_isr(void) __interrupt(P0INT_VECTOR)#else#pragma vector=P0INT_VECTOR__near_func __interrupt void port_0_isr(void)#endif 此时还有90个错误 12//__xdata __at(0x0000) static unsigned long timer_value = 0;static volatile unsigned long timer_value = 0; 修改了button-sensor.h 使之符合IAR格式 修改了button-sensor.c 清除了cc2531的情况 –这样做，不合算，仅是为了更快的修改而已，以后也要加上cc2531这种情况 123Error[e46]: Undefined external&quot;BUTTON_IRQ_CHECK::?relay&quot;referredinbutton-sensor ( F:\Contiki OS\2530contiki2.7\Debug\Obj\Error[e46]: Undefined external&quot;BUTTON_IRQ_FLAG_OFF::?relay&quot;referredinbutton-sensor ( F:\Contiki OS\2530contiki2.7\Debug\Obj\Error[e27]: Entry&quot;rime_sniffer_add::?relay&quot;inmodule rime ( F:\Contiki OS\2530contiki2.7\Debug\Obj\rime.r51 ) redefinedinmodule 1234567891011相应的文件没有添加上 Error[e46]: Undefined external &quot;autostart_processes&quot; referred in contiki-main ( F:\Contiki OS\2530contiki2.7\Debug\Obj\contiki-main.r51 ) 相应的文件没有添加上Error[e46]: Undefined external &quot;rtimer_arch_init::?relay&quot; referred in rtimer ( F:\Contiki OS\2530contiki2.7\Debug\Obj\rtimer.r51 ) 相应的文件没有添加上 Error[e46]: Undefined external &quot;?DPL1&quot; referred in cc2530-rf ( F:\Contiki OS\2530contiki2.7\Debug\Obj\cc2530-rf.r51 ) 在8051def.h 屏蔽了部分宏（没用明确定义） 12345678910111213//#if !defined(__SDCC_mcs51) &amp;&amp; !defined(SDCC_mcs51)//#define __data//#define __xdata//#define __code//#define __bit bool//#define __sfr volatile unsigned char//#define __sbit volatile bool//#define __critical//#define __at(x)//#define __using(x)//#define __interrupt(x)//#define __naked//#endif 在cc253x.h文件中主要修改了关于读取芯片MAC的地址，如下 12345678910/* ------------------------------------------------------------------------------------------------ * Flash * ------------------------------------------------------------------------------------------------ */ #define X_INFOPAGE PXREG( 0x7800 ) /* Pointer to Start of Flash Information Page */#define X_XBANK PXREG( 0x8000 ) /* Pointer to Start of Selectable Flash Bank (XBANK) *///#define X_IEEE_ADDR PXREG(0x780C ) /* Start of unique IEEE Address */#define X_IEEE_ADDR (*(uint8_t*)(X_INFOPAGE + 0x0C)) /* Start of unique IEEE Address */#define OVFIM T1OVFIM 主要是第8行，根据这个地址，程序可以读取芯片的MAC地址，由此作为网络IP或者节点IP等。系统莫名其名重启—溢出问题和看门狗设置1，修改看门狗启动— WDCTL|=0x08 2，溢出–适当减少XDATA； 编译器的bug—更改一次烧写 linker 换成128_banked.xcl (芯片对应版本) 就好了。 作者：古鲁咕噜 来源：CSDN 原文：https://blog.csdn.net/zzuzpb/article/details/48090521 版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>Contiki</category>
      </categories>
      <tags>
        <tag>Contiki</tag>
        <tag>CC2530</tag>
        <tag>嵌入式</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】Java Web开发环境配置]]></title>
    <url>%2F2019%2F03%2F13%2FJava-Web%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Java Web开发环境配置前言Java Web，是用Java技术来解决相关web互联网领域的技术总和。web包括：web服务器和web客户端两部分。Java在客户端的应用有java applet，不过使用得很少，Java在服务器端的应用非常的丰富，比如Servlet，JSP和第三方框架等等。Java技术对Web领域的发展注入了强大的动力。Java Web基于JavaEE平台开发。 第一步、安装配置JDK、JREJDK配置已在另一篇博客中详细讲解，若还没有配置JDK和JRE，请点击传送门 第二步、安装配置Tomcat服务器Tomcat官网传送门 Tomcat简介Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。 Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。 诀窍是，当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。另外，Tomcat和IIS等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态HTML的能力不如Apache服务器。目前Tomcat最新版本为9.0。 Tomcat下载根据自己的情况，选择任意版本下载即可，截止2019/3/13最新版本 Tomcat 7.0.93： Windows 32位传送门 Windows 64位传送门 Windows 32/64位安装程序传送门 Tomcat 8.5.38： Windows 32位传送门 Windows 64位传送门 Windows 32/64位安装程序传送门 Tomcat 9.0.16： Windows 32位传送门 Windows 64位传送门 Windows 32/64位安装程序传送门 配置Tomcat本地运行环境 首先将下载的压缩包解压到D盘，或者使用安装程序安装到D盘 添加变量CATALINA_HOME到环境变量，变量值为Tomcat解压路径 例如： |变量名|变量值| |:–|:–| |CATALINA_HOME|D:\appache-tomcat-8.5.38| 这里的变量值为你的Tomcat根目录 测试运行Tomcat 进入Tomcat安装路径下的bin目录，双击startup.bat文件，如果正常输出启动信息，并未输出任何异常，则Tomcat安装正确。（注意：弹出的命令窗口不能关闭，否则服务器将停止运行） 打开浏览器，在地址栏输入地址http://localhost:8080/或者http://127.0.0.1:8080/，如果能打开Tomcat配置页面，说明Tomcat配置成功。 在Tomcat开启的命令提示界面按下Ctrl+C键，将关闭Tomcat服务器。再次访问Tomcat配置页面，若出现网页不能访问，则说明Tomcat关闭成功。 结语感谢阅读，后面将继续讲解使用Eclipse和IDEA新建Java Web工程]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java Web</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Button的几种点击事件实现方法]]></title>
    <url>%2F2019%2F03%2F12%2FAndroid-Button%E7%9A%84%E5%87%A0%E7%A7%8D%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Button的几种点击事件实现方法前言Button介绍:Button(按钮)继承自TextView，在Android开发中，Button是常用的控件，用起来也很简单，你可以在界面xml描述文档中定义，也可以在程序中创建后加入到界面中，其效果都是一样的。不过最好是在xml文档中定义，因为一旦界面要改变是话，直接修改一下xml就行了，不用修改Java程序，并且在xml中定义层次分明，一目了然。 Button 支持的 XML 属性及相关方法 XML 属性 相关方法 说明 android:clickable setClickable(boolean clickable) 设置是否允许点击。clickable=true:允许点击clickable=false:禁止点击 android:background setBackgroundResource(int resid) 通过资源文件设置背景色。resid:资源xml文件ID按钮默认背景为android.R.drawable.btn_default android:text setText(CharSequence text) 设置文字 android:textColor setTextColor(int color) 设置文字颜色 android:onClick setOnClickListener(OnClickListener l) 设置点击事件 布局 效果展示 第一种、匿名内部类方法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; Integer flipCount = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button cardbutton = findViewById(R.id.cardButton); /** * 匿名内部类实现按钮点击事件 */ cardbutton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.cardButton: Button btn = findViewById(R.id.cardButton); if (btn.getText() == &quot;&quot;) &#123; btn.setText(&quot;A♥&quot;); btn.setBackgroundResource(R.drawable.blankcard); &#125; else &#123; btn.setText(&quot;&quot;); btn.setBackgroundResource(R.drawable.stanfordtree); &#125; flipCount++; TextView textView = findViewById(R.id.textView); textView.setText(&quot;您已经点击&quot; + flipCount + &quot;次卡片&quot;); break; &#125; &#125; &#125;); &#125;&#125; 第二种、自定义点击事件实现，继承View.OnClickListener12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; Integer flipCount = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button cardbutton = findViewById(R.id.cardButton); /** * 自定义点击事件实现，继承View.OnClickListener */ cardbutton.setOnClickListener(new MyOnClicklistener()); &#125; private class MyOnClicklistener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.cardButton: Button btn = findViewById(R.id.cardButton); if (btn.getText() == &quot;&quot;) &#123; btn.setText(&quot;A♥&quot;); btn.setBackgroundResource(R.drawable.blankcard); &#125; else &#123; btn.setText(&quot;&quot;); btn.setBackgroundResource(R.drawable.stanfordtree); &#125; flipCount++; TextView textView = findViewById(R.id.textView); textView.setText(&quot;您已经点击&quot; + flipCount + &quot;次卡片&quot;); break; &#125; &#125; &#125;&#125; 第三种、Activity继承View.OnClickListener，由Activity实现OnClick(View v)方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends AppCompatActivity implements OnClickListener &#123; Integer flipCount = 0; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.cardButton: Button btn = findViewById(R.id.cardButton); if (btn.getText() == &quot;&quot;) &#123; btn.setText(&quot;A♥&quot;); btn.setBackgroundResource(R.drawable.blankcard); &#125; else &#123; btn.setText(&quot;&quot;); btn.setBackgroundResource(R.drawable.stanfordtree); &#125; flipCount++; TextView textView = findViewById(R.id.textView); textView.setText(&quot;您已经点击&quot; + flipCount + &quot;次卡片&quot;); break; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button cardbutton = findViewById(R.id.cardButton); /** * Activity继承View.OnClickListener，由Activity实现OnClick(View v)方法 */ cardbutton.setOnClickListener(this); &#125;&#125; 第四种、Xml添加监听属性注意android:onClick属性设置 1234567891011121314&lt;Button android:id=&quot;@+id/cardButton&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;120dp&quot; android:layout_marginStart=&quot;8dp&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginEnd=&quot;8dp&quot; android:layout_marginBottom=&quot;8dp&quot; android:onClick=&quot;doClick&quot; android:text=&quot;@string/card_name&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; Integer flipCount = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; /** * Xml添加监听属性 * @param v */ protected void doClick(View v) &#123; switch (v.getId()) &#123; case R.id.cardButton: Button btn = findViewById(R.id.cardButton); if (btn.getText() == &quot;&quot;) &#123; btn.setText(&quot;A♥&quot;); btn.setBackgroundResource(R.drawable.blankcard); &#125; else &#123; btn.setText(&quot;&quot;); btn.setBackgroundResource(R.drawable.stanfordtree); &#125; flipCount++; TextView textView = findViewById(R.id.textView); textView.setText(&quot;您已经点击&quot; + flipCount + &quot;次卡片&quot;); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51单片机】4-点亮LED灯]]></title>
    <url>%2F2019%2F03%2F10%2F4-%E7%82%B9%E4%BA%AELED%E7%81%AF%2F</url>
    <content type="text"><![CDATA[点亮LED灯LED（发光二极管）的介绍LED全称为半导体发光二极管，采用半导体材料制成的，以直接将电能转化为光能，电号转换成光信号的发光器件；其特点是功耗低、高亮度、色彩艳丽、抗振动、寿命长（正常发光8-10万小时）、冷光源等优点，是真正“绿色照明”。以LED为光源的灯饰产品在21世纪的将来，必然取代白织灯，成为人类照明的又一次革命。 LED工作参数 普通发光二极管工作电压压降为： 1.6v ~ 2.1 v 工作电流为：1~20ma 根据欧姆定律我们可以算出A（电流）=V（电压）/R（电阻）可以算出电阻的阻值可以在150欧~3000欧之间 画出仿真电路 编写LED灯的点亮程序123456789101112131415161718192021222324252627282930313233/* * @Description: 随机点亮LED灯(流水灯) * @Author: 鱼摆摆 * @Github: https://github.com/FisherCloud * @Date: 2018-12-25 12:57:51 * @LastEditTime: 2019-03-10 09:26:28 */#include &lt;reg52.h&gt;#include &lt;stdlib.h&gt;#define LED P0void delay(unsigned int z)&#123; unsigned int x, y; for (x = z; x &gt; 0; x--) for (y = 110; y &gt; 0; y--) ;&#125;void main(void)&#123; int r = 0; do &#123; r = rand() % 256; LED = r; delay(100); &#125; while (1);&#125; 效果图 如果你觉得有什么不足，欢迎在下方评论区留言]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51单片机】3-51单片机最小系统]]></title>
    <url>%2F2019%2F03%2F09%2F3-51%E5%8D%95%E7%89%87%E6%9C%BA%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[51单片机最小系统电平特性单片机是一种数字集成芯片，数字电路中只有两种电平:高电平和低电平。我们学习的单片机呢就是TTL电平，其中高电平是5V，低电平是0V。 TTL电平信号被利用的最多是因为通常数据表示采用二进制规定，+5V等价于逻辑“1”，0V等价于逻辑“0”，这被称做TTL（晶体管-晶体管逻辑电平）信号系统，这是计算机处理器控制的设备内部各部分之间通信的标准技术。 数字电路中，由TTL电子元器件组成电路使用的电平。电平是个电压范围，规定输出高电平&gt;2.4V,输出低电平&lt;0.4V。在室温下，一般输出高电平是3.5V，输出低电平是0.2V。最小输入高电平和低电平：输入高电平&gt;=2.0V，输入低电平&lt;=0.8V 计算机串口用的是MAX232电平，其中高电平是-12V，低电平是+12V。 51单片机IO口介绍 单片机最小系统的组成 什么是机器周期 振荡周期: 也称时钟周期, 是指为单片机提供时钟脉冲信号的振荡源的周期。 机器周期: 一个机器周期包含 12 个时钟周期。 在一个机器周期内, CPU可以完成一个独立的操作。 如果你觉得有什么不足，欢迎在下方评论区留言]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51单片机】2-C语言基础]]></title>
    <url>%2F2019%2F03%2F09%2F2-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[C语言基础进制转换什么是十进制我们生活中常用的就是十进制数，十进制就是我们所说的0—9十个数，平时的计数都是按十进制计算的，比如“我们班一共有25个同学”其中的“25”就是十进制数。十进制是逢十进一，借一当时十。 二进制 二进制是逢二进一，借一当时二。 十进制和二进制的转换 十六进制 我们常用的十进制的0-15在十六进制中表示为：0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F其中从10-15是用A-F表示，字母不区分大小写 进制之间的转换 十进制25 转二进制为： 0001 1001B 转十六进制为：19H 换算方法 十进制转二进制的换算方法：用25/2 每次取余数； 25/2 = 12 余1 ，12/2 = 6 余 0，6/2=3 余0 ，3/2= 1余 1，剩下1不能被2整除了。我们把最后剩下的数和他每一次的余数倒序写。 十进制转十六进制的换算方法：用25/16=1余9。十六进制为19 C语言简介C语言的发展史 CPL -&gt; BCPL -&gt; B -&gt; C，其中： CPL（Combined programming Language），1963，英国剑桥； BCPL（Basic Combined programming Language）， 1967，英国剑桥； B，1970，美国贝尔 C，1972，美国贝尔（D.Ritchie) 1973年，K.Thompson和D.Ritchie合作，将UNIX重写一遍，从此奠定了操作系统的基础。 1978年以后，C语言先后移植到大、中、小、微型机上。 C语言在语言体系中的地位 C语言的特点 语言简洁、紧凑、使用灵活 运算符丰富 具有数据类型构造能力 具有很强的流程控制结构 语言生成的代码质量高 可移植性较好 语言限制不够严格 变量和常量常量和变量 常量就是一个固定不变的值，变量就可以随时改变值的量比如5+a=b；其中，5就是一个“常量”，而a，b就是一个“变量” ，变量的数值大小不一样所占用的内存空间就不一样，我们为了有效的节省内存空间要把变量和常量的数值范围进行定义，不同的数值范围所占用的内存大小不一样。 位（bit）和字节（byte） 位二进制数系统中，每个0或1就是一个位(bit)，位是内存的最小单位。 字节字节(Byte):8位二进制称为一字节。 C语言中常用的数据类型 C语言扩充定义(C51)：12sfr：特殊功能寄存器声明 如：sfr P0 = 0x80;sbit： 特殊功能位声明 如：sbit LED1 = P0^1； C语言运算符 算术运算符：+ - * /（加，减 ，乘 ，除） 位运算符： &amp; | ^ ~ &gt;&gt; &lt;&lt;(按位与，按位或，按位异或，按位取反，左移，右移) 逻辑运算符： &gt; &gt;= &lt; &lt;= == != &amp;&amp; || !(大于，大于等于，小于，小于等于，测试等于，测试不等于，逻辑与，逻辑或，逻辑非) C语言常用的控制语句 语句 释意 if()………else….. 条件判断语句 for() 循环语句 while() 循环语句 switch() 多分支选择语句 如果你觉得有什么不足，欢迎在下方评论区留言]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>51单片机</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【51单片机】1-认识和了解51单片机]]></title>
    <url>%2F2019%2F03%2F09%2F1-%E8%AE%A4%E8%AF%86%E5%92%8C%E4%BA%86%E8%A7%A351%E5%8D%95%E7%89%87%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[了解和认识51单片机学习51单片机需要哪些基础知识 会使用电脑 有C语言基础 了解简单的模拟电子和数字电路的知识 了解微型计算机的组成及应用形态 微型计算机的应用形态 将微处理器CPU、存储器（RAM、ROM）、基本输入/输出（I/O）接口电路和总线接口等组装在一块主机板（即微机主板）。各种适配（卡）插在主机板的扩展槽上并与电源、软/硬盘驱动器和光驱等装在同一机箱内，再配上系统软件，就构成了一台完整的微型计算机系统。微型计算机硬件组成如图所示。 单板微型计算机 将CPU芯片、存储器芯片、I/O接口芯片和简单的I/O设备（小键盘、LED显示器）等装配在一块印刷电路板上，再配上监控程序（固化在ROM中），就构成了一台单板微型计算机（简称单板机）。单板微型计算机组成如图所示。主要应用于工业控制器、家用电器等。 什么是单片机？ 单片机又称单片微控制器,它不是完成某一个逻辑功能的芯片,而是把一个计算机系统集成到一个芯片上。概括的讲：一块芯片就成了一台计算机。在一片集成电路芯片上集成中央处理器（CPU）、存储器（ROM/RAM）、I/O接口电路，从而构成了单芯片微型计算机，简称单片机。常用英文字母的缩写MCU表示单片机（Microcontroller Unit） 单片机内部结构单片机内部结构示意图如图所示，它由微处理器CPU、随机存取存储器RAM、只读存储器ROM、基本输入/输出(I/O)接口电路、定时器/计数器和中断系统等部件组成，并把它们制作在一块大规模集成电路芯片上，就构成一个完整的单片微型计算机。 单片机应用系统的组成单片机应用系统的组成如图所示。单片机应用系统是以单片机为核心，再加上接口电路及外设等硬件电路和软件，就构成了单片机应用系统。因此，单片机应用系统的设计人员必须从硬件和软件角度来研究单片机，这样才能研究 和开发出单片机应用系统和产品。 80C51单片机系列虽然目前单片机的品种很多，51系列的典型芯片是80C51（CHMOS型的8051）。为此，众多的厂商都介入了以80C51为代表的8位单片机的发展，如Philips、Siemens（Infineon）、Dallas、ATMEL、STC等公司，我们把这些公司生产的与80C51兼容的单片机统称为80C51系列。 如：ATMEL公司的AT89S51 AT89S52 AT89S53。 STC公司的STC89C51 STC89C52 STC89C53 STC公司的51单片机 STC公司单片机的命名规则 单片机的特点及应用领域单片机的特点单片机芯片的集成度非常高，它将微型计算机的主要部件都集成在一块芯片上，因此，具有如下特点： 体积小、重量轻、价格低、耗电少、易于产品化。 控制性能。 实时控制功能强、运行速度快。因为CPU可以对I/O端口直接进行指令操作，而且位指令操作能力更是其它计算机无法比拟的。 可靠性高。由于CPU、存储器及I/O接口集成在同一芯片内，各部件间的连接紧凑，数据在传送时受干扰的影响较小，且不易受环境条件的影响，所以单片机的可靠性非常高。 单片机的应用领域 家用电器。家用电器是单片机的重要应用领域之一，前景广阔。如微波炉、电视机、电饭煲、空调器、电冰箱、洗衣机等。 在交通领域中。如交通灯、汽车、火车、飞机等均有单片机的广泛应用。 智能仪器仪表。如各种智能电气测量仪表、智能传感器等。 机电一体化产品。如医疗设备（B超）、机人、数控机床、自动包装机、打印机、复印机等。 实时工业控制。如温度控制、电机转速控制、生产线控制等。 80C51与STC89C52的区别 Intel公司在1980年推出80C51系列单片机，由于80C51单片机应用早，影响面很大，已经成为工业标准。后来很多著名厂商如Atmel，philps等公司申请了版权，生产了各种与80C51兼容的单片机系列。虽然制造工艺在不断地改进，但内核却没有变化，指令系统完全兼容，而且大多数管脚也兼容。因此，我们称这些与80C51内核相同的单片机为80C51系列单片机或51系列单片机。 由于80C51单片机是早期产品，用户无法将自己编写的应用程序烧写到单片机内的存储器，只能将程序交由芯片厂商代为烧写，并且是一次性的。8751单片机的内部存储器有了改进，用户可以将自己编写的程序写入单片机的内部存储器中，但需要用紫外线灯照射25分钟以上再烧写，烧写次数和电压也是有一定限制的。 ST89C52单片机是STC公司生产的产品，它把80C51内核与Flash技术相结合，推出可在线编程的单片机。STC89C52单片机指令系统、管脚完全与80C51兼容。 单片机的发展趋势20世纪80年代以来，单片机有了新的发展，各半导体器件厂商也纷纷推出自己的产品系列。根据市场的需求要求，未来单片机的发展趋势有如下几个方面： 单片机的字长由4位、8位、16 位发展到32位。 目前8位的单片机仍然占主流地位，只有在精度要求特别高的场合如图像处理等，才采用16位或32位的单片机，用户可以根据需要进行字长的选择。 运行速度不断提高。 单片机的使用最高频率由6MHz、12MHz 、24MHz、33MHz发展到 40MHz和更高，用户可以根据产品的需要进行速度的选择。 如果你觉得有什么不足，欢迎在下方评论区留言]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>51单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Java】JDK安装配置]]></title>
    <url>%2F2019%2F03%2F09%2FJDK%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[JDK安装配置前言JDK是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的java应用程序。JDK是整个java开发的核心，它包含了JAVA的运行环境（JVM+Java系统类库）和JAVA工具。 下载JDK建议安装Java 1.8版本的JDK，这个版本应用广泛，对Android的支持更好！ 附上下载地址：请点击这里进入Oracle官网下载 选择JDK DOWNLOAD进入下载页面,先勾选Accept License Agreement,再根据自己的操作系统下载JDK 附上JDK-1.8.201下载地址:Windows_64位 JDK-1.8.201_Windows_x64 Windows_32位 JDK-1.8.201_Windows_xi586 其他版本请自行进官网下载 安装JDK下载完成后双击安装，选择安装目录，如果不是固态硬盘（SSD）或者固态硬盘容量小，请选择D盘为解压目录，点击完成，等待安装成功，JDK安装成功后安装程序下一步会提示你安装JRE，需要重新选择路径安装，我这里建议安装到这里可以点击取消安装JRE，因为现在的JDK中已经包含了JRE，不需要另外安装。 配置环境变量 选中“我的电脑”（或者“此电脑”），右键选中属性，点击高级系统设置 再选择环境变量 点击“新建”变量 变量名为：JAVA_HOME 变量值为：你的JDK所在路径 测试一下JRE是否安装成功，WIN+R输入CMD打开命令行，输入java -version，出现以下界面证明JDK安装成功，暂时不要关闭此窗口 再进入环境变量配置，新建变量：CLASSPATH，变量值复制以下内容即可 1%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 再打开刚刚的命令行窗口，输入javac，出现以下内容即JDK安装配置成功 JDK的安装配置就到这里，如果你觉得有什么不足，欢迎在下方评论区留言]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Android】Android Studio 安装配置简介]]></title>
    <url>%2F2019%2F03%2F09%2FAndroid-Studio-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Android Studio 安装配置简介前言：Android Studio 是谷歌推出的一个Android集成开发工具，基于IntelliJ IDEA. 类似 Eclipse ADT，Android Studio 提供了集成的 Android 开发工具用于开发和调试。 安装：安装JDK:安装JDK就不在这里详细赘述了，请查看我的另一篇博文《JDK安装配置》 安装Android Studio安装Android Studio有两种方法 方法一：直接下载Android Studio安装附上下载链接，请使用浏览器打开链接进行下载，不要用迅雷下载、不要用迅雷下载、不要用迅雷下载，重要的事情说三遍 Windows 64位点击下载 Windows 32位点击下载 安装过程不做详细赘述，注意安装路径即可 方法二：使用Jetbrains公司的ToolBox下载 选择版本下载，我们这里选择Windows版本下载，其他系统请下载相应安装包 附上Windows版本下载链接点击下载 下载完成后，安装即可，安装完成后打开ToolBox，ToolBox界面如下，我已经安装过了 先不要安装，点击右上角设置，更改开发工具的安装路径，建议安装在D盘，然后返回上一级安装即可 配置SDK附上SDK tool下载链接点击下载 下载完成后解压缩到D盘，D://Android/SDK/你的SDK根目录 然后打开Android Studio 第一次进入会进行各种设置，最重要的是选择Android SDK的系统环境，进入Android studio后新建一个工程选择空白的Android工程，选择Android版本，创建成功之后，IDE会自动下载相关依赖和环境，等待下载完成即可 未完待续~ 详细介绍后续补齐 如果你觉得有什么不足，欢迎在下方评论区留言]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Linux期末复习]]></title>
    <url>%2F2019%2F03%2F08%2FLinux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Linux期末复习资料🐧作者：鱼摆摆 2019-01-08 update for 2019-03-8 适用于四川师范大学计算机科学学院Linux高级程序设计课程 教师：张莹 一、选择题（Linux命令） 20’ who: 显示所有正在使用系统的用户、所用终端名、注册到系统的时间 -H 或 –heading：显示各栏位的标题信息列； -i 或 -u 或 –idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成”.”号，如果该用户已超过24小时没有任何动作，则标示出”old”字符串； -m：此参数的效果和指定”am i”字符串相同； -q 或–count：只显示登入系统的帐号名称和总人数； -s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题； echo: 输出命令，后面接输出内容，引号可加可不加 1echo -e &quot;OK! \n&quot; # -e 开启转义 date: 用来显示或设定系统的日期与时间 -u : 显示目前的格林威治时间 pwd: 显示当前路径 ls: 显示文件、目录信息 -l: 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出@import “ls-l.png” -a: 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出) -r: 将文件以相反次序显示(原定依英文字母次序) -t: 将文件依建立时间之先后次序列出 -A: 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录) -R: 若目录下有文件，则以下之文件亦皆依序列出 cat: 用于连接文件并打印到标准输出设备上 -n 或 –number：由 1 开始对所有输出的行数编号。 -b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。 -s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。 -v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。 -E 或 –show-ends : 在每行结束处显示 $。 -T 或 –show-tabs: 将 TAB 字符显示为 ^I。 -A, –show-all：等价于 -vET。 rm: 用于删除一个文件或者目录 -i 删除前逐一询问确认。 -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。 -r 将目录及以下之档案亦逐一删除。 cp: 用于复制文件或目录 -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。 -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。 -f：覆盖已经存在的目标文件而不给出提示。 -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。 -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。 -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。 -l：不复制文件，只是生成链接文件。 touch: 用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件 a 改变档案的读取时间记录。 m 改变档案的修改时间记录。 c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。 f 不使用，是为了与其他 unix 系统的相容性而保留。 r 使用参考档的时间记录，与 –file 的效果一样。 d 设定时间与日期，可以使用各种不同的格式。 t 设定档案的时间记录，格式与 date 指令相同。 cd: 用于切换当前工作目录至 dirName(目录参数) 跳到 /usr/bin/ : 1cd /usr/bin 跳到自己的 home 目录 : 1cd ~ 跳到目前目录的上一层 : 1cd .. mkdir: 用于建立名称为 dirName 之子目录 -p 确保目录名称存在，不存在的就建一个。 rmdir: 删除空目录 -p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除。 wc: 用于计算字数 -c或–bytes或–chars 只显示Bytes数。 -l或–lines 只显示行数。 -w或–words 只显示字数。 time: time命令的用途，在于量测特定指令执行时所需消耗的时间及系统资源等资讯 -o 或 –output=FILE：设定结果输出档。这个选项会将 time 的输出写入 所指定的档案中。如果档案已经存在，系统将覆写其内容。 -a 或 –append：配合 -o 使用，会将结果写到档案的末端，而不会覆盖掉原来的内容。 -f FORMAT 或 –format=FORMAT：以 FORMAT 字串设定显示方式。当这个选项没有被设定的时候，会用系统预设的格式。不过你可以用环境变数 time 来设定这个格式，如此一来就不必每次登入系统都要设定一次。 chmod: 改变文件操作权限 u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作 -f : 若该文件权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) chown: 将指定文件的拥有者改为指定的用户或组 -c : 显示更改的部分的信息 -f : 忽略错误信息 -h :修复符号链接 -v : 显示详细的处理信息 -R : 处理指定目录以及其子目录下的所有文件 tar: 用于压缩（备份）文件 -A或–catenate 新增文件到已存在的备份文件。 -b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt; 设置每笔记录的区块数目，每个区块大小为12Bytes。 -B或–read-full-records 读取数据时重设区块大小。 -c或–create 建立新的备份文件。 -C&lt;目的目录&gt;或–directory=&lt;目的目录&gt; 切换到指定的目录。 -d或–diff或–compare 对比备份文件内和文件系统上的文件的差异。 -f&lt;备份文件&gt;或–file=&lt;备份文件&gt; 指定备份文件。 -F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt; 每次更换磁带时，就执行指定的Script文件。 -g或–listed-incremental 处理GNU格式的大量备份。 -G或–incremental 处理旧的GNU格式的大量备份。 -h或–dereference 不建立符号连接，直接复制该连接所指向的原始文件。 -i或–ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。 -k或–keep-old-files 解开备份文件时，不覆盖已有的文件。 -K&lt;文件&gt;或–starting-file=&lt;文件&gt; 从指定的文件开始还原。 -l或–one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。 -L&lt;媒体容量&gt;或-tape-length=&lt;媒体容量&gt; 设置存放每体的容量，单位以1024 Bytes计算。 -m或–modification-time 还原文件时，不变更文件的更改时间。 -M或–multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。 -N&lt;日期格式&gt;或–newer=&lt;日期时间&gt; 只将较指定日期更新的文件保存到备份文件里。 -o或–old-archive或–portability 将资料写入备份文件时使用V7格式。 -O或–stdout 把从备份文件里还原的文件输出到标准输出设备。 -p或–same-permissions 用原来的文件权限还原文件。 -P或–absolute-names 文件名使用绝对名称，不移除文件名称前的”/“号。 -r或–append 新增文件到已存在的备份文件的结尾部分。 -R或–block-number 列出每个信息在备份文件中的区块编号。 -s或–same-order 还原文件的顺序和备份文件内的存放顺序相同。 -S或–sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。 -t或–list 列出备份文件的内容。 -T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。 -u或–update 仅置换较备份文件内的文件更新的文件。 -U或–unlink-first 解开压缩文件还原文件之前，先解除文件的连接。 -v或–verbose 显示指令执行过程。 -V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt; 建立使用指定的卷册名称的备份文件。 -w或–interactive 遭遇问题时先询问用户。 -W或–verify 写入备份文件后，确认文件正确无误。 -x或–extract或–get 从备份文件中还原文件。 -X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt; 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。 -z或–gzip或–ungzip 通过gzip指令处理备份文件。 -Z或–compress或–uncompress 通过compress指令处理备份文件。实例 压缩文件 非打包 123# touch a.c # tar -zcvf test.tar.gz a.c //压缩 a.c文件为test.tar.gza.c 解压文件 12# tar -zxvf test.tar.gz a.c passwd: 用来更改使用者的密码 -d 删除密码 -f 强制执行 -k 更新只能发送在过期之后 -l 停止账号使用 -S 显示密码信息 -u 启用已被停止的账户 -x 设置密码的有效期 -g 修改群组密码 -i 过期后停止用户账号 uesradd: 用于建立用户帐号 -c&lt;备注&gt; 加上备注文字。备注文字会保存在passwd的备注栏位中。 -d&lt;登入目录&gt; 指定用户登入时的启始目录。 -D 变更预设值． -e&lt;有效期限&gt; 指定帐号的有效期限。 -f&lt;缓冲天数&gt; 指定在密码过期后多少天即关闭该帐号。 -g&lt;群组&gt; 指定用户所属的群组。 -G&lt;群组&gt; 指定用户所属的附加群组。 -m 自动建立用户的登入目录。 -M 不要自动建立用户的登入目录。 -n 取消建立以用户名称为名的群组． -r 建立系统帐号。 -s\ 指定用户登入后所使用的shell。 -u\ 指定用户ID。 实例 添加一般用户 1# useradd tt 为添加的用户指定相应的用户组 1# useradd -g root tt 创建一个系统用户 1# useradd -r tt 为新添加的用户指定home目录 1# useradd -d /home/myd tt 建立用户且制定ID 1# useradd caojh -u 544 userdel: 用于删除用户帐号 -r 删除用户登入目录以及目录中所有文件。 实例 删除用户账号1# userdel hnlinux grep: 用于查找文件里符合条件的字符串 -a 或 –text : 不要忽略二进制的数据。 -A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。 -c 或 –count : 计算符合样式的列数。 -C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d &lt;动作&gt; 或 –directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。 -e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。 -E 或 –extended-regexp : 将样式为延伸的普通表示法来使用。 -f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -F 或 –fixed-regexp : 将样式视为固定字符串的列表。 -G 或 –basic-regexp : 将样式视为普通的表示法来使用。 -h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。 -i 或 –ignore-case : 忽略字符大小写的差别。 -l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。 -L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。 -n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。 -o 或 –only-matching : 只显示匹配PATTERN 部分。 -q 或 –quiet或–silent : 不显示任何信息。 -r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。 -s 或 –no-messages : 不显示错误信息。 -v 或 –revert-match : 显示不包含匹配文本的所有行。 -V 或 –version : 显示版本信息。 -w 或 –word-regexp : 只显示全字符合的列。 -x –line-regexp : 只显示全列符合的列。 -y : 此参数的效果和指定”-i”参数相同。 实例 1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： 1grep test *file 2、以递归的方式查找符合条件的文件。例如，查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容，使用的命令为： 1grep -r update /etc/acpi 3、反向查找。前面各个例子是查找并打印出符合条件的行，通过”-v”参数可以打印出不符合条件行的内容。查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为： 1grep -v test *test* ps: 用于显示当前进程 (process) 的状态 -A 列出所有的行程 -w 显示加宽可以显示较多的资讯 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 au(x) 输出格式 : USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND USER: 行程拥有者 PID: pid %CPU: 占用的 CPU 使用率 %MEM: 占用的记忆体使用率 VSZ: 占用的虚拟记忆体大小 RSS: 占用的记忆体大小 TTY: 终端的次要装置号码 (minor device number of tty) STAT: 该行程的状态: D: 不可中断的静止 (通悸□□缜b进行 I/O 动作) R: 正在执行中 S: 静止状态 T: 暂停执行 Z: 不存在但暂时无法消除 W: 没有足够的记忆体分页可分配 &lt;: 高优先序的行程 N: 低优先序的行程 L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O) START: 行程开始时间 TIME: 执行的时间 COMMAND:所执行的指令 kill: 用于删除执行中的程序或工作、也可将指定的信号送至程序 -l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。 -s &lt;信息名称或编号&gt; 指定要送出的信息。 [程序] [程序]可以是程序的PID或是PGID，也可以是工作编号。 实例 杀死进程 1# kill 12345 强制杀死进程 1# kill -KILL 123456 发送SIGHUP信号，可以使用一下信号 1# kill -HUP pid 彻底杀死进程 1# kill -9 123456 显示信号 1234567891011121314# kill -l1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX 杀死指定用户所有进程 12#kill -9 $(ps -ef | grep hnlinux) //方法一 过滤出hnlinux用户进程 #kill -u hnlinux //方法二 mount: 用于挂载Linux系统外的文件 -V：显示程序版本 -h：显示辅助讯息 -v：显示较讯息，通常和 -f 用来除错。 -a：将 /etc/fstab 中定义的所有档案系统挂上。 -F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。 -f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。 -n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。 -s-r：等于 -o ro -w：等于 -o rw -L：将含有特定标签的硬盘分割挂上。 -U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。 -t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。 -o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。 -o sync：在同步模式下执行。 -o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。 -o auto、-o noauto：打开/关闭自动挂上模式。 -o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async. -o dev、-o nodev-o exec、-o noexec允许执行档被执行。 -o suid、-o nosuid： 允许执行档在 root 权限下执行。 -o user、-o nouser：使用者可以执行 mount/umount 的动作。 -o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。 -o ro：用唯读模式挂上。 -o rw：用可读写模式挂上。 -o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。 实例 12mount -t iso9660 /dev/cdrom/mnt/cdrommount -t nfs 127.0.0.1:/mnt/nfs/mnt/nfs umount: 用于卸除文件系统 -a 卸除/etc/mtab中记录的所有文件系统。 -h 显示帮助。 -n 卸除时不要将信息存入/etc/mtab文件中。 -r 若无法成功卸除，则尝试以只读的方式重新挂入文件系统。 -t&lt;文件系统类型&gt; 仅卸除选项中所指定的文件系统。 -v 执行时显示详细的信息。 -V 显示版本信息。 [文件系统] 除了直接指定文件系统外，也可以用设备名称或挂入点来表示文件系统。 实例 下面两条命令分别通过设备名和挂载点卸载文件系统，同时输出详细信息：1234# umount -v /dev/sda1 通过设备名卸载 /dev/sda1 umounted # umount -v /mnt/mymount/ 通过挂载点卸载 /tmp/diskboot.img umounted vi: 文本编辑器 二、GDB填空题 20’gcc编译- GCC编译过程： -预处理 -编译 -汇编 -链接 基本语法格式：⚠️⚠️⚠️ 12# gcc -c 源文件名.c# gcc -o 生成的可执行文件名（可任意，通常为源文件名去掉后缀）源文件名.o 静态库的创建和使用：:warning: 1、编写源文件libhello.h linhello.c 2、生成目标文件libhello.o 1gcc -c libhello.c -o libhello.o 3、使用ar命令创建静态库libhello.a 12ar -rc libhello.a libhello.ofile lib hello.a 4、静态库的使用： 编辑测试文件usehello.c，生成可执行文件usehello_static 1gcc –o usehello_static usehello.c libhello.a 动态库的创建和使用：⚠️ 1、编写源文件libhello.h linhello.c 2、生成共享库目标文件libhello.o 1gcc -fPIC -Wall -g -c libhello.c -o libhello.o 3、编译共享库libhello.so.1.0 12gcc -g -shared -W1,-soname,libhello.so -o libhello.so.1.0 libhello.ofile lib hello.so.1.0 4、创建共享库的符号链接 1ln –s libhello.so.1.0 libhello.so 5、动态库的使用： 编辑测试文件usehello.c，生成可执行文件usehello_dy 12gcc –g –o usehello_dy usehello.c –lhello –L ./LD_LIBRARY_PATH=$(pwd) ./usehello_dy gdb调试器- gdb调试必须加上参数 -g 1# gcc -g text.c -o text 调试 1# gdb filename 参数列表- 命令 命令缩写 命令说明 list l 显示多行源代码 break b 设置断点,程序运行到断点的位置会停下来 info i 描述程序的状态 run r 开始运行程序 display disp 跟踪查看某个变量,每次停下来都显示它的值 step s 执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句 next n 执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句) print p 打印内部变量值 continue c 继续程序的运行,直到遇到下一个断点 set var name=v 设置变量的值 start st 开始执行程序,在main函数的第一条语句前面停下来 file 装入需要调试的程序 kill k 终止正在调试的程序 watch 监视变量值的变化 backtrace bt 产看函数调用信息(堆栈) frame f 查看栈帧 quit q 退出GDB环境 三、shell编程（上机测试 +-\/ function cdManager） 10’* 运行 Shell 脚本有两种方法： 1、作为可执行程序 将上面的代码保存为 test.sh，并 cd 到相应目录： 12chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本 注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 2、作为解释器参数 这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： 12/bin/sh test.sh/bin/php test.php 系统预定义变量 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 算术运算符 下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 -10。 * 乘法 expr $a \* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 算术运算符实例如下：12345678910111213141516171819202122232425262728#!/bin/basha=10b=20val=`expr $a + $b`echo &quot;a + b : $val&quot;val=`expr $a - $b`echo &quot;a - b : $val&quot;val=`expr $a \* $b`echo &quot;a * b : $val&quot;val=`expr $b / $a`echo &quot;b / a : $val&quot;val=`expr $b % $a`echo &quot;b % a : $val&quot;if [ $a == $b ]then echo &quot;a 等于 b&quot;fiif [ $a != $b ]then echo &quot;a 不等于 b&quot;fi 执行脚本，输出结果如下所示：123456a + b : 30a - b : -10a * b : 200b / a : 2b % a : 0a 不等于 b 注意：⚠️ 乘号(*)前边必须加反斜杠()才能实现乘法运算； if…then…fi 是条件语句，后续将会讲解。 在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*” 不需要转义符号 “\” 。 关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 关系运算符实例如下：1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/basha=10b=20if [ $a -eq $b ]then echo &quot;$a -eq $b : a 等于 b&quot;else echo &quot;$a -eq $b: a 不等于 b&quot;fiif [ $a -ne $b ]then echo &quot;$a -ne $b: a 不等于 b&quot;else echo &quot;$a -ne $b : a 等于 b&quot;fiif [ $a -gt $b ]then echo &quot;$a -gt $b: a 大于 b&quot;else echo &quot;$a -gt $b: a 不大于 b&quot;fiif [ $a -lt $b ]then echo &quot;$a -lt $b: a 小于 b&quot;else echo &quot;$a -lt $b: a 不小于 b&quot;fiif [ $a -ge $b ]then echo &quot;$a -ge $b: a 大于或等于 b&quot;else echo &quot;$a -ge $b: a 小于 b&quot;fiif [ $a -le $b ]then echo &quot;$a -le $b: a 小于或等于 b&quot;else echo &quot;$a -le $b: a 大于 b&quot;fi 执行脚本，输出结果如下所示：12345610 -eq 20: a 不等于 b10 -ne 20: a 不等于 b10 -gt 20: a 不大于 b10 -lt 20: a 小于 b10 -ge 20: a 小于 b10 -le 20: a 小于或等于 b 布尔运算符 下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 布尔运算符实例如下：1234567891011121314151617181920212223242526272829#!/bin/basha=10b=20if [ $a != $b ]then echo &quot;$a != $b : a 不等于 b&quot;else echo &quot;$a != $b: a 等于 b&quot;fiif [ $a -lt 100 -a $b -gt 15 ]then echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;else echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;fiif [ $a -lt 100 -o $b -gt 100 ]then echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;else echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;fiif [ $a -lt 5 -o $b -gt 100 ]then echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;else echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;fi 执行脚本，输出结果如下所示：123410 != 20 : a 不等于 b10 小于 100 且 20 大于 15 : 返回 true10 小于 100 或 20 大于 100 : 返回 true10 小于 5 或 20 大于 100 : 返回 false 逻辑运算符 以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20: 运算符 说明 举例 &amp;&amp; 逻辑的 AND [ $a -lt 100 &amp;&amp; $b -gt 100 ] 返回 false &#124;&#124; 逻辑的 OR [ $a -lt 100 &#124;&#124; $b -gt 100 ] 返回 true 逻辑运算符实例如下：123456789101112131415161718#!/bin/basha=10b=20if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]then echo &quot;返回 true&quot;else echo &quot;返回 false&quot;fiif [[ $a -lt 100 || $b -gt 100 ]]then echo &quot;返回 true&quot;else echo &quot;返回 false&quot;fi 执行脚本，输出结果如下所示：12返回 false返回 true 字符串运算符 下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 字符串运算符实例如下：1234567891011121314151617181920212223242526272829303132333435#!/bin/basha=&quot;abc&quot;b=&quot;efg&quot;if [ $a = $b ]then echo &quot;$a = $b : a 等于 b&quot;else echo &quot;$a = $b: a 不等于 b&quot;fiif [ $a != $b ]then echo &quot;$a != $b : a 不等于 b&quot;else echo &quot;$a != $b: a 等于 b&quot;fiif [ -z $a ]then echo &quot;-z $a : 字符串长度为 0&quot;else echo &quot;-z $a : 字符串长度不为 0&quot;fiif [ -n &quot;$a&quot; ]then echo &quot;-n $a : 字符串长度不为 0&quot;else echo &quot;-n $a : 字符串长度为 0&quot;fiif [ $a ]then echo &quot;$a : 字符串不为空&quot;else echo &quot;$a : 字符串为空&quot;fi 执行脚本，输出结果如下所示：12345abc = efg: a 不等于 babc != efg : a 不等于 b-z abc : 字符串长度不为 0-n abc : 字符串长度不为 0abc : 字符串不为空 文件测试运算符 文件测试运算符用于检测 Unix 文件的各种属性。 属性检测描述如下： 运算符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 变量 file 表示文件”/var/www/runoob/test.sh”，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bashfile=&quot;/var/www/runoob/test.sh&quot;if [ -r $file ]then echo &quot;文件可读&quot;else echo &quot;文件不可读&quot;fiif [ -w $file ]then echo &quot;文件可写&quot;else echo &quot;文件不可写&quot;fiif [ -x $file ]then echo &quot;文件可执行&quot;else echo &quot;文件不可执行&quot;fiif [ -f $file ]then echo &quot;文件为普通文件&quot;else echo &quot;文件为特殊文件&quot;fiif [ -d $file ]then echo &quot;文件是个目录&quot;else echo &quot;文件不是个目录&quot;fiif [ -s $file ]then echo &quot;文件不为空&quot;else echo &quot;文件为空&quot;fiif [ -e $file ]then echo &quot;文件存在&quot;else echo &quot;文件不存在&quot;fi 执行脚本，输出结果如下所示：1234567文件可读文件可写文件可执行文件为普通文件文件不是个目录文件不为空文件存在 Shell 流程控制 if else if if 语句语法格式：1234567if conditionthen command1 command2 ... commandN fi 写成一行（适用于终端命令提示符）：1if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi 末尾的fi就是if倒过来拼写，后面还会遇到类似的。 if else if else 语法格式：123456789if conditionthen command1 command2 ... commandNelse commandfi if else-if else if else-if else 语法格式：123456789if condition1then command1elif condition2 then command2else commandNfi 以下实例判断两个变量是否相等：1234567891011121314a=10b=20if [ $a == $b ]then echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then echo &quot;a 大于 b&quot;elif [ $a -lt $b ]thenecho &quot;a 小于 b&quot;else echo &quot;没有符合的条件&quot;fi 输出结果：1a 小于 b if else语句经常与test命令结合使用，如下所示：12345678num1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo &apos;两个数字相等!&apos;else echo &apos;两个数字不相等!&apos;fi 输出结果：1两个数字相等! for 循环 for循环一般格式为：1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 写成一行：1for var in item1 item2 ... itemN; do command1; command2… done; 当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。 in列表是可选的，如果不用它，for循环使用命令行的位置参数。 例如，顺序输出当前列表中的数字：1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done 输出结果：12345The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5 顺序输出字符串中的字符：1234for str in &apos;This is a string&apos;do echo $strdone 输出结果：1234Thisisastring while 语句 while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：1234while conditiondo commanddone 以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。1234567#!/bin/bashint=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done 运行脚本，输出：1234512345 无限循环 无限循环语法格式：12345678910while :do commanddone或者while truedo commanddone 或者1for (( ; ; )) until 循环 until 循环执行一系列命令直至条件为 true 时停止。 until 循环与 while 循环在处理方式上刚好相反。 一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。 until 语法格式:1234until conditiondo commanddone condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。 以下实例我们使用 until 命令来输出 0 ~ 9 的数字：123456789#!/bin/basha=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done 运行结果：123456789100123456789 case Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。 case语句格式如下：1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 下面的脚本提示输入1到4，与每一种模式进行匹配：123456789101112131415echo &apos;输入 1 到 4 之间的数字:&apos;echo &apos;你输入的数字为:&apos;read aNumcase $aNum in 1) echo &apos;你选择了 1&apos; ;; 2) echo &apos;你选择了 2&apos; ;; 3) echo &apos;你选择了 3&apos; ;; 4) echo &apos;你选择了 4&apos; ;; *) echo &apos;你没有输入 1 到 4 之间的数字&apos; ;;esac 输入不同的内容，会有不同的结果，例如：1234输入 1 到 4 之间的数字:你输入的数字为:3你选择了 3 esac case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。 跳出循环 在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。 break命令 break命令允许跳出所有循环（终止执行后面的所有循环）。 下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。123456789101112131415#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot; break ;; esacdone 执行以上代码，输出结果为：1234输入 1 到 5 之间的数字:3你输入的数字为 3!输入 1 到 5 之间的数字:7你输入的数字不是 1 到 5 之间的! 游戏结束 continue命令 continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环，与C语言一样。 对上面break的例子进行修改：12345678910111213141516#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot; continue echo &quot;游戏结束&quot; ;; esacdone 运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “游戏结束” 永远不会被执行。 四、内存纠错（指出错误、修改错误） 10’==内存实验代码相关内容搞清楚== 代码区（text segment）。加载的是可执行文件代码段，其加载到内存中的位置由加载器完成。 全局初始化数据区/静态数据区（Data Segment）。加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据）的数据的生存周期为整个程序运行过程。 未初始化数据区（BSS）。加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。 栈区（stack）。由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。 堆区（heap）。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS回收。 常见的内存错误： 返回局部变量地址错误 临时空间过大：如定义数组的大小过大 空指针 滥用 泄漏：通常指堆内存泄露。即通过malloc、realloc和new等函数分配内存造成的 出现原因：堆内存分配后，未释放；堆内存分配后，释放顺序不当 例题⚠️⚠️⚠️ 示例1： 12345678910void GetMemory(char *p, int num)&#123;p = (char *)malloc(sizeof(char) * num);&#125;void Test(void)&#123;char *str = NULL;GetMemory(str, 100); strcpy(str, &quot;hello&quot;);&#125; ==错误：== （1）空指针非法操作。因为str与p之间是值传递，在函数GetMemory调用结束后，p分配空 （2）在函数GetMemory中分配的空间没有回收，导致内存泄露。 改正： 参见示例2和示例3。 示例2： 12345678910111213void GetMemory2(char **p, int num)&#123;*p = (char *)malloc(sizeof(char) * num);&#125;void Test2(void)&#123;char *str = NULL;GetMemory2(&amp;str, 100); strcpy(str, &quot;hello&quot;);cout&lt;&lt; str &lt;&lt; endl;free(str);&#125; ==正确== 示例3 1234567891011121314char *GetMemory3(int num)&#123;char *p = (char *)malloc(sizeof(char) * num);return p;&#125;void Test3(void)&#123;char *str = NULL;str = GetMemory3(100);strcpy(str, &quot;hello&quot;);cout&lt;&lt; str &lt;&lt; endl;free(str);&#125; ==正确== 示例4 123456789101112char *GetString(void)&#123;char p[] = &quot;hello world&quot;;return p;&#125;void Test4(void)&#123;char *str = NULL;str = GetString();cout&lt;&lt; str &lt;&lt; endl;&#125; ==错误:== （1）出现乱码打印。因为在函数GetString中，p数组拷贝了字符串常量“hello world”的值，但函数调用结束后，p数组回收导致这段空间内容被篡改，但p数组首地址确能成功返回指针变量str中，所有str可以输出，但内容确不是”hello world”。 改正： 参见示例5。 示例5 123456789101112char *GetString2(void)&#123;char *p = &quot;hello world&quot;;return p;&#125;void Test5(void)&#123;char *str = NULL;str = GetString2();cout&lt;&lt; str &lt;&lt; endl;&#125; ==正确== 五、问答题 40’ ls -l⚠️⚠️⚠️ 进程 获取进程的各种ID (非负数) 12345678#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t getpid(void); pid_t getppid(void);uid_t getuid(void); //获得进程的实际用户IDuid_t geteuid(void); /获得进程的有效用户IDgid_t getgid(void); //获得进程的实际组IDgid_t getegid(void); //获得进程的有效组ID 创建进程 （fork） 12#include &lt;unistd.h&gt;pid_t fork(void); 例题⚠️⚠️⚠️ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int hours = 0;int seconds = -1;int minutes = 0;void handler(int signal) &#123; seconds++; if (seconds == 60) &#123; minutes++; seconds = 0; if (minutes == 60) &#123; hours++; minutes = 0; if (hours == 24) &#123; hours = 0; &#125; &#125; &#125; printf(&quot;\r%02d:%02d:%02d&quot;, hours, minutes, seconds); fflush(stdout);//清空缓存&#125;int main() &#123; pid_t pid = fork();//创建子进程 pid_t ppid; if (pid == 0) &#123; ppid = getppid();//获取父进程的id while (1) &#123; kill(ppid, SIGALRM);//接受信号 sleep(1); &#125; &#125; else if (pid != -1) &#123; signal(SIGALRM, handler);//安装SIGALRM信号 while (1) &#123; pause();//等待接受信号 &#125; &#125; else &#123; printf(&quot;fork error!&quot;); &#125; return 0;&#125; 问题：⚠️有几个进程？描述整个过程⚠️ 线程 编译，不要忘了-lpthread⚠️⚠️⚠️ 1gcc -o test test.c -lpthread 线程控制函数⚠️⚠️⚠️ 创建线程 pthread_create 12345678#include &lt;pthread.h&gt;int pthread_create(pthread_t * tidp, const pthread_attr_t *attr, void *(*start_rtn)(void *), void *arg); // 返回：成功返回0，出错返回错误编号参数：参数1：是一个传出参数，用于保存成功创建线程之后对应的线程id。参数2：表示线程的属性，通常默认传NULL，如果想使用具体的属性也可以修改具体的参数。参数3：函数指针，一个指向函数的指针。指向创建线程所执行函数的入口地址，函数执行完毕，则线程结束。参数4：线程主函数执行期间所使用的参数。 当pthread_create函数返回成功时，有tidp指向的内存被设置为新创建线程的线程ID，其类型pthread_t定义为： 12#include &lt;bits/pthreadtypes.h&gt;typedef unsigned long int pthread_t; attr参数用于设置各种不同的线程属性，为NULL时表示默认线程属性。新创建的线程从start_rtn函数的地址开始运行，该函数只有一个无类型指针的参数arg，如果需要向start_rtn函数传入的参数不止一个，可以把参数放入到一个结构中，然后把这个结构的地址作为arg的参数传入。 线程创建时并不能保证哪个线程会先运行：是新创建的线程还是调用线程。新创建的线程可以访问调用进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字，但是该线程的未决信号集被清除。那什么是未决信号呢，信号产生到信号被处理这段时间间隔，称信号是未决的。 终止线程 pthread_exit 1234#include &lt;pthread.h&gt;void pthread_exit(void *rval_ptr); // 线程终止参数：retval表示线程的退出状态，通常穿NULL。当要求传出具体的退出状态时，可以使用retval。 线程在结束时最好调用该函数，以确保安全、干净的退出。pthread_exit函数通过rval_ptr参数向调用线程的回收者传递退出信息，进程中的其他线程可以调用pthread_join函数访问到这个指针。 pthread_exit执行完后不会返回到调用者，而且永远不会失败。 线程可以通过以下三种方式退出，在不终止整个进程的情况下停止它的控制流： 线程只是从启动过程中退出，返回值是线程的退出码 线程可以被同一进程中的其他线程取消 线程调用pthread_exit 等待线程 pthread_join 1234#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **rval_ptr); // 返回：成功返回0，出错返回错误代码参数： pthread为线程id，retval为线程的状态。可以与pthread_exit()结合使用。 调用该函数的线程将挂起等待，为阻塞的状态。直到id为thread的线程终止。thread线程以不同的方法终止，通过pthread_join得到的终止状态是不同的，总结如下： 如果thread线程通过return返回，retval所指向的单元里存放的是thread线程函数的返回值。 如果thread线程被别的线程调用pthread_cancel异常终止掉，retval所指向的单元里存放的是常数PTHREAD_CANCELED。 如果thread线程是自己调用pthread_exit终止的，retval所指向的单元存放的是传给pthread_exit的参数。 如果对thread线程的终止状态不感兴趣，可以传NULL给retval参数。 其他的内容嘛，自己想我为什么不写*😄😄😄 makefile 多说无义，直接上题⚠️⚠️⚠️ 阅读Makefile文件，回答问题： 如果注释掉all : libmys.so语句的话，需要输入指定执行规则make libmys.so运行 123456789all : libmys.soSRC=f1.c f2.c f3.cTGT=$(patsubst %.c,%.o,$(SRC)) #子串替换%.o : %.c #模式规则 所有.c通过执行gcc指令获得.o文件 cc -c $? #代表依赖文件f1.c f2.c f3.clibmys.so : $(TGT) cc -shared -o $@ $(TGT)clean: rm -f $(TGT) 回答以下问题： A: 此Makefile文件的主要功能是什么？ 1创建名为libmys.so的动态库 此Makefile文件包含多少个规则？它们分别是什么？ 124个；分别是 all 、 %.o 、 libmys.so 、 clean（有几个冒号，就有几个规则） 使用此Makefile文件可以生成目标文件f2.o吗？为什么？ 1可以生成f2.o 因为有%.o : %.c 这一模式规则，该规则 使所有的.c的依赖文件编译生成.o的目标文件。 此Makefile中，请指出存在的伪目标名称。 1all、clean 请写出$(TGT)的值。 1$(TGT)的值为：f1.o f2.o f3.o B: 此Makefile文件中，可以生成共享库，请指出共享库名字。 1libmys.so 如果测试该生成共享库的源文件test.c，请将它编译生成可执行程序并运行。 123gcc test.c -o test -lmys -L ./LD_LIBRARY_PATH=./ ./test 此Makefile文件中，除了显式规则，还使用了哪种规则，请指出并解释。 1234还使用了模式规则：%.o : %.ccc -c $?该规则使所有的.c的依赖文件编译生成.o的目标文件。 此Makefile文件中，all表示什么目标？ 1伪目标 此Makefile中，请指出使用的函数并解释其功能。 1TGT=$(patsubst %.c,%.o,$(SRC)) ：运用patsubst（替换通配符），将$(SRC)中所有的末尾为.c的字符串替换为末尾为.o的字符串。 C: 此Makefile文件的主要功能是什么，如何通过命令执行出结果？ 1生成共享库libmys.so，执行指令make 或者make all 请描述该Makefile文件获得执行结果的过程 1234① 声明所需要的文件名② 为f1.c f2.c f3.c生成.o文件③ 将所生成的.o文件生成共享库④ 清除中间生成的文件 $?的值是什么？ 1f1.c f2.c f3.c]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
